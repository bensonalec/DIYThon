	@memoize
	def file(self):
		pos = self.mark()
		if (True and
		 ((n0 := self.synthetic_rule_1()) or True) is not None and
		 (n1 := self.expect(tokenize.ENDMARKER)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def interactive(self):
		pos = self.mark()
		if (True and
		 (n0 := self.statement_newline()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def eval(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expressions()) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 (n2 := self.expect(tokenize.ENDMARKER)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def func_type(self):
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		 ((n1 := self.synthetic_rule_2()) or True) is not None and
		 self.expect(')') is not None and
		 self.expect('->') is not None and
		 (n4 := self.expression()) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 (n6 := self.expect(tokenize.ENDMARKER)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def fstring(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_expressions()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def type_expressions(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_4()) is not None and
		 self.expect(',') is not None and
		 self.expect('*') is not None and
		 (n3 := self.expression()) is not None and
		 self.expect(',') is not None and
		 self.expect('**') is not None and
		 (n6 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n7 := self.synthetic_rule_6()) is not None and
		 self.expect(',') is not None and
		 self.expect('*') is not None and
		 (n10 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n11 := self.synthetic_rule_8()) is not None and
		 self.expect(',') is not None and
		 self.expect('**') is not None and
		 (n14 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('*') is not None and
		 (n16 := self.expression()) is not None and
		 self.expect(',') is not None and
		 self.expect('**') is not None and
		 (n19 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('*') is not None and
		 (n21 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('**') is not None and
		 (n23 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n24 := self.synthetic_rule_10()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def statements(self):
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def statement(self):
		pos = self.mark()
		if (True and
		 (n0 := self.compound_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.simple_stmts()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def statement_newline(self):
		pos = self.mark()
		if (True and
		 (n0 := self.compound_stmt()) is not None and
		 (n1 := self.expect(tokenize.NEWLINE)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.simple_stmts()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.expect(tokenize.NEWLINE)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.expect(tokenize.ENDMARKER)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def simple_stmts(self):
		pos = self.mark()
		if (True and
		 (n0 := self.simple_stmt()) is not None and
		 self.lookahead(!, self.expect, ';') is not None and
		 (n2 := self.expect(tokenize.NEWLINE)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.synthetic_rule_12()) is not None and
		 ((n4 := self.synthetic_rule_13()) or True) is not None and
		 (n5 := self.expect(tokenize.NEWLINE)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def simple_stmt(self):
		pos = self.mark()
		if (True and
		 (n0 := self.assignment()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.star_expressions()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.return_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.import_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.raise_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('pass') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n6 := self.del_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n7 := self.yield_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n8 := self.assert_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('break') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('continue') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n11 := self.global_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n12 := self.nonlocal_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def compound_stmt(self):
		pos = self.mark()
		if (True and
		 (n0 := self.function_def()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.if_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.class_def()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.with_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.for_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n5 := self.try_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n6 := self.while_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n7 := self.match_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def assignment(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NAME)) is not None and
		 self.expect(':') is not None and
		 (n2 := self.expression()) is not None and
		 ((n3 := self.synthetic_rule_14()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.synthetic_rule_15()) is not None and
		 self.expect(':') is not None and
		 (n6 := self.expression()) is not None and
		 ((n7 := self.synthetic_rule_16()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		 (n9 := self.synthetic_rule_18()) is not None and
		 self.lookahead(!, self.expect, '=') is not None and
		 ((n11 := self.synthetic_rule_19()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n12 := self.single_target()) is not None and
		 (n13 := self.augassign()) is not None and
		 True is not None and
		 (n15 := self.synthetic_rule_20()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def augassign(self):
		pos = self.mark()
		if (True and
		 self.expect('+=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('-=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('*=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('@=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('/=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('%=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('&=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('|=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('^=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('<<=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('>>=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('**=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('//=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def global_stmt(self):
		pos = self.mark()
		if (True and
		 self.expect('global') is not None and
		 (n1 := self.synthetic_rule_22()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def nonlocal_stmt(self):
		pos = self.mark()
		if (True and
		 self.expect('nonlocal') is not None and
		 (n1 := self.synthetic_rule_24()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def yield_stmt(self):
		pos = self.mark()
		if (True and
		 (n0 := self.yield_expr()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def assert_stmt(self):
		pos = self.mark()
		if (True and
		 self.expect('assert') is not None and
		 (n1 := self.expression()) is not None and
		 ((n2 := self.synthetic_rule_25()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def del_stmt(self):
		pos = self.mark()
		if (True and
		 self.expect('del') is not None and
		 (n1 := self.del_targets()) is not None and
		 self.lookahead(&, self.expect, (';' | NEWLINE)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def import_stmt(self):
		pos = self.mark()
		if (True and
		 (n0 := self.import_name()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.import_from()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def import_name(self):
		pos = self.mark()
		if (True and
		 self.expect('import') is not None and
		 (n1 := self.dotted_as_names()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def import_from(self):
		pos = self.mark()
		if (True and
		 self.expect('from') is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		 (n2 := self.dotted_name()) is not None and
		 self.expect('import') is not None and
		 (n4 := self.import_from_targets()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('from') is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		 self.expect('import') is not None and
		 (n8 := self.import_from_targets()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def import_from_targets(self):
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		 (n1 := self.import_from_as_names()) is not None and
		 ((n2 := self.synthetic_rule_29()) or True) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.import_from_as_names()) is not None and
		 self.lookahead(!, self.expect, ',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('*') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def import_from_as_names(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_31()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def import_from_as_name(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NAME)) is not None and
		 ((n1 := self.synthetic_rule_32()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def dotted_as_names(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_34()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def dotted_as_name(self):
		pos = self.mark()
		if (True and
		 (n0 := self.dotted_name()) is not None and
		 ((n1 := self.synthetic_rule_35()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize_left_rec
	def dotted_name(self):
		pos = self.mark()
		if (True and
		 (n0 := self.dotted_name()) is not None and
		 self.expect('.') is not None and
		 (n2 := self.expect(tokenize.NAME)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.expect(tokenize.NAME)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def if_stmt(self):
		pos = self.mark()
		if (True and
		 self.expect('if') is not None and
		 (n1 := self.named_expression()) is not None and
		 self.expect(':') is not None and
		 (n3 := self.block()) is not None and
		 (n4 := self.elif_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('if') is not None and
		 (n6 := self.named_expression()) is not None and
		 self.expect(':') is not None and
		 (n8 := self.block()) is not None and
		 ((n9 := self.synthetic_rule_36()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def elif_stmt(self):
		pos = self.mark()
		if (True and
		 self.expect('elif') is not None and
		 (n1 := self.named_expression()) is not None and
		 self.expect(':') is not None and
		 (n3 := self.block()) is not None and
		 (n4 := self.elif_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('elif') is not None and
		 (n6 := self.named_expression()) is not None and
		 self.expect(':') is not None and
		 (n8 := self.block()) is not None and
		 ((n9 := self.synthetic_rule_37()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def else_block(self):
		pos = self.mark()
		if (True and
		 self.expect('else') is not None and
		 self.expect(':') is not None and
		 (n2 := self.block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def while_stmt(self):
		pos = self.mark()
		if (True and
		 self.expect('while') is not None and
		 (n1 := self.named_expression()) is not None and
		 self.expect(':') is not None and
		 (n3 := self.block()) is not None and
		 ((n4 := self.synthetic_rule_38()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def for_stmt(self):
		pos = self.mark()
		if (True and
		 self.expect('for') is not None and
		 (n1 := self.star_targets()) is not None and
		 self.expect('in') is not None and
		 True is not None and
		 (n4 := self.star_expressions()) is not None and
		 self.expect(':') is not None and
		 ((n6 := self.synthetic_rule_39()) or True) is not None and
		 (n7 := self.block()) is not None and
		 ((n8 := self.synthetic_rule_40()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n9 := self.expect(tokenize.ASYNC)) is not None and
		 self.expect('for') is not None and
		 (n11 := self.star_targets()) is not None and
		 self.expect('in') is not None and
		 True is not None and
		 (n14 := self.star_expressions()) is not None and
		 self.expect(':') is not None and
		 ((n16 := self.synthetic_rule_41()) or True) is not None and
		 (n17 := self.block()) is not None and
		 ((n18 := self.synthetic_rule_42()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def with_stmt(self):
		pos = self.mark()
		if (True and
		 self.expect('with') is not None and
		 self.expect('(') is not None and
		 (n2 := self.synthetic_rule_44()) is not None and
		 (self.expect(',') or True) is not None and
		 self.expect(')') is not None and
		 self.expect(':') is not None and
		 (n6 := self.block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('with') is not None and
		 (n8 := self.synthetic_rule_46()) is not None and
		 self.expect(':') is not None and
		 ((n10 := self.synthetic_rule_47()) or True) is not None and
		 (n11 := self.block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n12 := self.expect(tokenize.ASYNC)) is not None and
		 self.expect('with') is not None and
		 self.expect('(') is not None and
		 (n15 := self.synthetic_rule_49()) is not None and
		 (self.expect(',') or True) is not None and
		 self.expect(')') is not None and
		 self.expect(':') is not None and
		 (n19 := self.block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n20 := self.expect(tokenize.ASYNC)) is not None and
		 self.expect('with') is not None and
		 (n22 := self.synthetic_rule_51()) is not None and
		 self.expect(':') is not None and
		 ((n24 := self.synthetic_rule_52()) or True) is not None and
		 (n25 := self.block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def with_item(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expression()) is not None and
		 self.expect('as') is not None and
		 (n2 := self.star_target()) is not None and
		 self.lookahead(&, self.expect, (',' | ')' | ':')) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def try_stmt(self):
		pos = self.mark()
		if (True and
		 self.expect('try') is not None and
		 self.expect(':') is not None and
		 (n2 := self.block()) is not None and
		 (n3 := self.finally_block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('try') is not None and
		 self.expect(':') is not None and
		 (n6 := self.block()) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 ((n8 := self.synthetic_rule_54()) or True) is not None and
		 ((n9 := self.synthetic_rule_55()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def except_block(self):
		pos = self.mark()
		if (True and
		 self.expect('except') is not None and
		 (n1 := self.expression()) is not None and
		 ((n2 := self.synthetic_rule_56()) or True) is not None and
		 self.expect(':') is not None and
		 (n4 := self.block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('except') is not None and
		 self.expect(':') is not None and
		 (n7 := self.block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def finally_block(self):
		pos = self.mark()
		if (True and
		 self.expect('finally') is not None and
		 self.expect(':') is not None and
		 (n2 := self.block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def match_stmt(self):
		pos = self.mark()
		if (True and
		 self.expect("match") is not None and
		 (n1 := self.subject_expr()) is not None and
		 self.expect(':') is not None and
		 (n3 := self.expect(tokenize.NEWLINE)) is not None and
		 (n4 := self.expect(tokenize.INDENT)) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 (n6 := self.expect(tokenize.DEDENT)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def subject_expr(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_named_expression()) is not None and
		 self.expect(',') is not None and
		 ((n2 := self.star_named_expressions()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.named_expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def case_block(self):
		pos = self.mark()
		if (True and
		 self.expect("case") is not None and
		 (n1 := self.patterns()) is not None and
		 ((n2 := self.guard()) or True) is not None and
		 self.expect(':') is not None and
		 (n4 := self.block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def guard(self):
		pos = self.mark()
		if (True and
		 self.expect('if') is not None and
		 (n1 := self.named_expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def patterns(self):
		pos = self.mark()
		if (True and
		 (n0 := self.open_sequence_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def pattern(self):
		pos = self.mark()
		if (True and
		 (n0 := self.as_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.or_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def as_pattern(self):
		pos = self.mark()
		if (True and
		 (n0 := self.or_pattern()) is not None and
		 self.expect('as') is not None and
		 (n2 := self.pattern_capture_target()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def or_pattern(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_58()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def closed_pattern(self):
		pos = self.mark()
		if (True and
		 (n0 := self.literal_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.capture_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.wildcard_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.value_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.group_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n5 := self.sequence_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n6 := self.mapping_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n7 := self.class_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def literal_pattern(self):
		pos = self.mark()
		if (True and
		 (n0 := self.signed_number()) is not None and
		 self.lookahead(!, self.expect, ('+' | '-')) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.complex_number()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.strings()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('None') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('True') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('False') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def literal_expr(self):
		pos = self.mark()
		if (True and
		 (n0 := self.signed_number()) is not None and
		 self.lookahead(!, self.expect, ('+' | '-')) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.complex_number()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.strings()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('None') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('True') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('False') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def complex_number(self):
		pos = self.mark()
		if (True and
		 (n0 := self.signed_real_number()) is not None and
		 self.expect('+') is not None and
		 (n2 := self.imaginary_number()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.signed_real_number()) is not None and
		 self.expect('-') is not None and
		 (n5 := self.imaginary_number()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def signed_number(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NUMBER)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('-') is not None and
		 (n2 := self.expect(tokenize.NUMBER)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def signed_real_number(self):
		pos = self.mark()
		if (True and
		 (n0 := self.real_number()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('-') is not None and
		 (n2 := self.real_number()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def real_number(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NUMBER)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def imaginary_number(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NUMBER)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def capture_pattern(self):
		pos = self.mark()
		if (True and
		 (n0 := self.pattern_capture_target()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def pattern_capture_target(self):
		pos = self.mark()
		if (True and
		 self.lookahead(!, self.expect, "_") is not None and
		 (n1 := self.expect(tokenize.NAME)) is not None and
		 self.lookahead(!, self.expect, ('.' | '(' | '=')) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def wildcard_pattern(self):
		pos = self.mark()
		if (True and
		 self.expect("_") is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def value_pattern(self):
		pos = self.mark()
		if (True and
		 (n0 := self.attr()) is not None and
		 self.lookahead(!, self.expect, ('.' | '(' | '=')) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize_left_rec
	def attr(self):
		pos = self.mark()
		if (True and
		 (n0 := self.name_or_attr()) is not None and
		 self.expect('.') is not None and
		 (n2 := self.expect(tokenize.NAME)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize_left_rec
	def name_or_attr(self):
		pos = self.mark()
		if (True and
		 (n0 := self.attr()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.expect(tokenize.NAME)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def group_pattern(self):
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		 (n1 := self.pattern()) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def sequence_pattern(self):
		pos = self.mark()
		if (True and
		 self.expect('[') is not None and
		 ((n1 := self.maybe_sequence_pattern()) or True) is not None and
		 self.expect(']') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		 ((n4 := self.open_sequence_pattern()) or True) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def open_sequence_pattern(self):
		pos = self.mark()
		if (True and
		 (n0 := self.maybe_star_pattern()) is not None and
		 self.expect(',') is not None and
		 ((n2 := self.maybe_sequence_pattern()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def maybe_sequence_pattern(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_64()) is not None and
		 (self.expect(',') or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def maybe_star_pattern(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def star_pattern(self):
		pos = self.mark()
		if (True and
		 self.expect('*') is not None and
		 (n1 := self.pattern_capture_target()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('*') is not None and
		 (n3 := self.wildcard_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def mapping_pattern(self):
		pos = self.mark()
		if (True and
		 self.expect('{') is not None and
		 self.expect('}') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('{') is not None and
		 (n3 := self.double_star_pattern()) is not None and
		 (self.expect(',') or True) is not None and
		 self.expect('}') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('{') is not None and
		 (n7 := self.items_pattern()) is not None and
		 self.expect(',') is not None and
		 (n9 := self.double_star_pattern()) is not None and
		 (self.expect(',') or True) is not None and
		 self.expect('}') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('{') is not None and
		 (n13 := self.items_pattern()) is not None and
		 (self.expect(',') or True) is not None and
		 self.expect('}') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def items_pattern(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_66()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def key_value_pattern(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_67()) is not None and
		 self.expect(':') is not None and
		 (n2 := self.pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def double_star_pattern(self):
		pos = self.mark()
		if (True and
		 self.expect('**') is not None and
		 (n1 := self.pattern_capture_target()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def class_pattern(self):
		pos = self.mark()
		if (True and
		 (n0 := self.name_or_attr()) is not None and
		 self.expect('(') is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.name_or_attr()) is not None and
		 self.expect('(') is not None and
		 (n5 := self.positional_patterns()) is not None and
		 (self.expect(',') or True) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n8 := self.name_or_attr()) is not None and
		 self.expect('(') is not None and
		 (n10 := self.keyword_patterns()) is not None and
		 (self.expect(',') or True) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n13 := self.name_or_attr()) is not None and
		 self.expect('(') is not None and
		 (n15 := self.positional_patterns()) is not None and
		 self.expect(',') is not None and
		 (n17 := self.keyword_patterns()) is not None and
		 (self.expect(',') or True) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def positional_patterns(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_69()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def keyword_patterns(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_71()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def keyword_pattern(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NAME)) is not None and
		 self.expect('=') is not None and
		 (n2 := self.pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def return_stmt(self):
		pos = self.mark()
		if (True and
		 self.expect('return') is not None and
		 ((n1 := self.synthetic_rule_72()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def raise_stmt(self):
		pos = self.mark()
		if (True and
		 self.expect('raise') is not None and
		 (n1 := self.expression()) is not None and
		 ((n2 := self.synthetic_rule_73()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('raise') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def function_def(self):
		pos = self.mark()
		if (True and
		 (n0 := self.decorators()) is not None and
		 (n1 := self.function_def_raw()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.function_def_raw()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def function_def_raw(self):
		pos = self.mark()
		if (True and
		 self.expect('def') is not None and
		 (n1 := self.expect(tokenize.NAME)) is not None and
		 self.expect('(') is not None and
		 ((n3 := self.synthetic_rule_74()) or True) is not None and
		 self.expect(')') is not None and
		 ((n5 := self.synthetic_rule_75()) or True) is not None and
		 self.expect(':') is not None and
		 ((n7 := self.synthetic_rule_76()) or True) is not None and
		 (n8 := self.block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n9 := self.expect(tokenize.ASYNC)) is not None and
		 self.expect('def') is not None and
		 (n11 := self.expect(tokenize.NAME)) is not None and
		 self.expect('(') is not None and
		 ((n13 := self.synthetic_rule_77()) or True) is not None and
		 self.expect(')') is not None and
		 ((n15 := self.synthetic_rule_78()) or True) is not None and
		 self.expect(':') is not None and
		 ((n17 := self.synthetic_rule_79()) or True) is not None and
		 (n18 := self.block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def func_type_comment(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NEWLINE)) is not None and
		 (n1 := self.expect(tokenize.TYPE_COMMENT)) is not None and
		 self.lookahead(&, self.expect, (NEWLINE INDENT)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.expect(tokenize.TYPE_COMMENT)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def params(self):
		pos = self.mark()
		if (True and
		 (n0 := self.parameters()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def parameters(self):
		pos = self.mark()
		if (True and
		 (n0 := self.slash_no_default()) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 ((n3 := self.synthetic_rule_81()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.slash_with_default()) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 ((n6 := self.synthetic_rule_82()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 ((n9 := self.synthetic_rule_83()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 ((n11 := self.synthetic_rule_84()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n12 := self.star_etc()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def slash_no_default(self):
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 self.expect('/') is not None and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 self.expect('/') is not None and
		 self.lookahead(&, self.expect, ')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def slash_with_default(self):
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 self.expect('/') is not None and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 self.expect('/') is not None and
		 self.lookahead(&, self.expect, ')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def star_etc(self):
		pos = self.mark()
		if (True and
		 self.expect('*') is not None and
		 (n1 := self.param_no_default()) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 ((n3 := self.synthetic_rule_85()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('*') is not None and
		 self.expect(',') is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 ((n7 := self.synthetic_rule_86()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n8 := self.kwds()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def kwds(self):
		pos = self.mark()
		if (True and
		 self.expect('**') is not None and
		 (n1 := self.param_no_default()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def param_no_default(self):
		pos = self.mark()
		if (True and
		 (n0 := self.param()) is not None and
		 self.expect(',') is not None and
		 ((n2 := self.expect(tokenize.TYPE_COMMENT)) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.param()) is not None and
		 ((n4 := self.expect(tokenize.TYPE_COMMENT)) or True) is not None and
		 self.lookahead(&, self.expect, ')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def param_with_default(self):
		pos = self.mark()
		if (True and
		 (n0 := self.param()) is not None and
		 (n1 := self.default()) is not None and
		 self.expect(',') is not None and
		 ((n3 := self.expect(tokenize.TYPE_COMMENT)) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.param()) is not None and
		 (n5 := self.default()) is not None and
		 ((n6 := self.expect(tokenize.TYPE_COMMENT)) or True) is not None and
		 self.lookahead(&, self.expect, ')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def param_maybe_default(self):
		pos = self.mark()
		if (True and
		 (n0 := self.param()) is not None and
		 ((n1 := self.default()) or True) is not None and
		 self.expect(',') is not None and
		 ((n3 := self.expect(tokenize.TYPE_COMMENT)) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.param()) is not None and
		 ((n5 := self.default()) or True) is not None and
		 ((n6 := self.expect(tokenize.TYPE_COMMENT)) or True) is not None and
		 self.lookahead(&, self.expect, ')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def param(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NAME)) is not None and
		 ((n1 := self.annotation()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def annotation(self):
		pos = self.mark()
		if (True and
		 self.expect(':') is not None and
		 (n1 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def default(self):
		pos = self.mark()
		if (True and
		 self.expect('=') is not None and
		 (n1 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def decorators(self):
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def class_def(self):
		pos = self.mark()
		if (True and
		 (n0 := self.decorators()) is not None and
		 (n1 := self.class_def_raw()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.class_def_raw()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def class_def_raw(self):
		pos = self.mark()
		if (True and
		 self.expect('class') is not None and
		 (n1 := self.expect(tokenize.NAME)) is not None and
		 ((n2 := self.synthetic_rule_89()) or True) is not None and
		 self.expect(':') is not None and
		 (n4 := self.block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def block(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NEWLINE)) is not None and
		 (n1 := self.expect(tokenize.INDENT)) is not None and
		 (n2 := self.statements()) is not None and
		 (n3 := self.expect(tokenize.DEDENT)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.simple_stmts()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def star_expressions(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_expression()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		 ((n2 := self.synthetic_rule_91()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.star_expression()) is not None and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n5 := self.star_expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def star_expression(self):
		pos = self.mark()
		if (True and
		 self.expect('*') is not None and
		 (n1 := self.bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def star_named_expressions(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_93()) is not None and
		 ((n1 := self.synthetic_rule_94()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def star_named_expression(self):
		pos = self.mark()
		if (True and
		 self.expect('*') is not None and
		 (n1 := self.bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.named_expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def assignment_expression(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NAME)) is not None and
		 self.expect(':=') is not None and
		 True is not None and
		 (n3 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def named_expression(self):
		pos = self.mark()
		if (True and
		 (n0 := self.assignment_expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.expression()) is not None and
		 self.lookahead(!, self.expect, ':=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def annotated_rhs(self):
		pos = self.mark()
		if (True and
		 (n0 := self.yield_expr()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.star_expressions()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def expressions(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expression()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		 ((n2 := self.synthetic_rule_96()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.expression()) is not None and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n5 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def expression(self):
		pos = self.mark()
		if (True and
		 (n0 := self.disjunction()) is not None and
		 self.expect('if') is not None and
		 (n2 := self.disjunction()) is not None and
		 self.expect('else') is not None and
		 (n4 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n5 := self.disjunction()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n6 := self.lambdef()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def lambdef(self):
		pos = self.mark()
		if (True and
		 self.expect('lambda') is not None and
		 ((n1 := self.synthetic_rule_97()) or True) is not None and
		 self.expect(':') is not None and
		 (n3 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def lambda_params(self):
		pos = self.mark()
		if (True and
		 (n0 := self.lambda_parameters()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def lambda_parameters(self):
		pos = self.mark()
		if (True and
		 (n0 := self.lambda_slash_no_default()) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 ((n3 := self.synthetic_rule_98()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.lambda_slash_with_default()) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 ((n6 := self.synthetic_rule_99()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 ((n9 := self.synthetic_rule_100()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 ((n11 := self.synthetic_rule_101()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n12 := self.lambda_star_etc()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def lambda_slash_no_default(self):
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 self.expect('/') is not None and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 self.expect('/') is not None and
		 self.lookahead(&, self.expect, ':') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def lambda_slash_with_default(self):
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 self.expect('/') is not None and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 self.expect('/') is not None and
		 self.lookahead(&, self.expect, ':') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def lambda_star_etc(self):
		pos = self.mark()
		if (True and
		 self.expect('*') is not None and
		 (n1 := self.lambda_param_no_default()) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 ((n3 := self.synthetic_rule_102()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('*') is not None and
		 self.expect(',') is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		 ((n7 := self.synthetic_rule_103()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n8 := self.lambda_kwds()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def lambda_kwds(self):
		pos = self.mark()
		if (True and
		 self.expect('**') is not None and
		 (n1 := self.lambda_param_no_default()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def lambda_param_no_default(self):
		pos = self.mark()
		if (True and
		 (n0 := self.lambda_param()) is not None and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.lambda_param()) is not None and
		 self.lookahead(&, self.expect, ':') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def lambda_param_with_default(self):
		pos = self.mark()
		if (True and
		 (n0 := self.lambda_param()) is not None and
		 (n1 := self.default()) is not None and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.lambda_param()) is not None and
		 (n4 := self.default()) is not None and
		 self.lookahead(&, self.expect, ':') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def lambda_param_maybe_default(self):
		pos = self.mark()
		if (True and
		 (n0 := self.lambda_param()) is not None and
		 ((n1 := self.default()) or True) is not None and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.lambda_param()) is not None and
		 ((n4 := self.default()) or True) is not None and
		 self.lookahead(&, self.expect, ':') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def lambda_param(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NAME)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def disjunction(self):
		pos = self.mark()
		if (True and
		 (n0 := self.conjunction()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.conjunction()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def conjunction(self):
		pos = self.mark()
		if (True and
		 (n0 := self.inversion()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.inversion()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def inversion(self):
		pos = self.mark()
		if (True and
		 self.expect('not') is not None and
		 (n1 := self.inversion()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.comparison()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def comparison(self):
		pos = self.mark()
		if (True and
		 (n0 := self.bitwise_or()) is not None and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def compare_op_bitwise_or_pair(self):
		pos = self.mark()
		if (True and
		 (n0 := self.eq_bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.noteq_bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.lte_bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.lt_bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.gte_bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n5 := self.gt_bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n6 := self.notin_bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n7 := self.in_bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n8 := self.isnot_bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n9 := self.is_bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def eq_bitwise_or(self):
		pos = self.mark()
		if (True and
		 self.expect('==') is not None and
		 (n1 := self.bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def noteq_bitwise_or(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_106()) is not None and
		 (n1 := self.bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def lte_bitwise_or(self):
		pos = self.mark()
		if (True and
		 self.expect('<=') is not None and
		 (n1 := self.bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def lt_bitwise_or(self):
		pos = self.mark()
		if (True and
		 self.expect('<') is not None and
		 (n1 := self.bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def gte_bitwise_or(self):
		pos = self.mark()
		if (True and
		 self.expect('>=') is not None and
		 (n1 := self.bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def gt_bitwise_or(self):
		pos = self.mark()
		if (True and
		 self.expect('>') is not None and
		 (n1 := self.bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def notin_bitwise_or(self):
		pos = self.mark()
		if (True and
		 self.expect('not') is not None and
		 self.expect('in') is not None and
		 (n2 := self.bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def in_bitwise_or(self):
		pos = self.mark()
		if (True and
		 self.expect('in') is not None and
		 (n1 := self.bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def isnot_bitwise_or(self):
		pos = self.mark()
		if (True and
		 self.expect('is') is not None and
		 self.expect('not') is not None and
		 (n2 := self.bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def is_bitwise_or(self):
		pos = self.mark()
		if (True and
		 self.expect('is') is not None and
		 (n1 := self.bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize_left_rec
	def bitwise_or(self):
		pos = self.mark()
		if (True and
		 (n0 := self.bitwise_or()) is not None and
		 self.expect('|') is not None and
		 (n2 := self.bitwise_xor()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.bitwise_xor()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize_left_rec
	def bitwise_xor(self):
		pos = self.mark()
		if (True and
		 (n0 := self.bitwise_xor()) is not None and
		 self.expect('^') is not None and
		 (n2 := self.bitwise_and()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.bitwise_and()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize_left_rec
	def bitwise_and(self):
		pos = self.mark()
		if (True and
		 (n0 := self.bitwise_and()) is not None and
		 self.expect('&') is not None and
		 (n2 := self.shift_expr()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.shift_expr()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize_left_rec
	def shift_expr(self):
		pos = self.mark()
		if (True and
		 (n0 := self.shift_expr()) is not None and
		 self.expect('<<') is not None and
		 (n2 := self.sum()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.shift_expr()) is not None and
		 self.expect('>>') is not None and
		 (n5 := self.sum()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n6 := self.sum()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize_left_rec
	def sum(self):
		pos = self.mark()
		if (True and
		 (n0 := self.sum()) is not None and
		 self.expect('+') is not None and
		 (n2 := self.term()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.sum()) is not None and
		 self.expect('-') is not None and
		 (n5 := self.term()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n6 := self.term()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize_left_rec
	def term(self):
		pos = self.mark()
		if (True and
		 (n0 := self.term()) is not None and
		 self.expect('*') is not None and
		 (n2 := self.factor()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.term()) is not None and
		 self.expect('/') is not None and
		 (n5 := self.factor()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n6 := self.term()) is not None and
		 self.expect('//') is not None and
		 (n8 := self.factor()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n9 := self.term()) is not None and
		 self.expect('%') is not None and
		 (n11 := self.factor()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n12 := self.term()) is not None and
		 self.expect('@') is not None and
		 (n14 := self.factor()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n15 := self.factor()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def factor(self):
		pos = self.mark()
		if (True and
		 self.expect('+') is not None and
		 (n1 := self.factor()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('-') is not None and
		 (n3 := self.factor()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('~') is not None and
		 (n5 := self.factor()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n6 := self.power()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def power(self):
		pos = self.mark()
		if (True and
		 (n0 := self.await_primary()) is not None and
		 self.expect('**') is not None and
		 (n2 := self.factor()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.await_primary()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def await_primary(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.AWAIT)) is not None and
		 (n1 := self.primary()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.primary()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize_left_rec
	def primary(self):
		pos = self.mark()
		if (True and
		 (n0 := self.primary()) is not None and
		 self.expect('.') is not None and
		 (n2 := self.expect(tokenize.NAME)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.primary()) is not None and
		 (n4 := self.genexp()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n5 := self.primary()) is not None and
		 self.expect('(') is not None and
		 ((n7 := self.synthetic_rule_107()) or True) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n9 := self.primary()) is not None and
		 self.expect('[') is not None and
		 (n11 := self.slices()) is not None and
		 self.expect(']') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n13 := self.atom()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def slices(self):
		pos = self.mark()
		if (True and
		 (n0 := self.slice()) is not None and
		 self.lookahead(!, self.expect, ',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.synthetic_rule_109()) is not None and
		 ((n3 := self.synthetic_rule_110()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def slice(self):
		pos = self.mark()
		if (True and
		 ((n0 := self.synthetic_rule_111()) or True) is not None and
		 self.expect(':') is not None and
		 ((n2 := self.synthetic_rule_112()) or True) is not None and
		 ((n3 := self.synthetic_rule_114()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.named_expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def atom(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NAME)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('True') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('False') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('None') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.strings()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n5 := self.expect(tokenize.NUMBER)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n6 := self.synthetic_rule_115()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n7 := self.synthetic_rule_116()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n8 := self.synthetic_rule_117()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('...') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def strings(self):
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def list(self):
		pos = self.mark()
		if (True and
		 self.expect('[') is not None and
		 ((n1 := self.synthetic_rule_118()) or True) is not None and
		 self.expect(']') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def listcomp(self):
		pos = self.mark()
		if (True and
		 self.expect('[') is not None and
		 (n1 := self.named_expression()) is not None and
		 (n2 := self.for_if_clauses()) is not None and
		 self.expect(']') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def tuple(self):
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		 ((n1 := self.synthetic_rule_120()) or True) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def group(self):
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		 (n1 := self.synthetic_rule_121()) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def genexp(self):
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		 (n1 := self.synthetic_rule_122()) is not None and
		 (n2 := self.for_if_clauses()) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def set(self):
		pos = self.mark()
		if (True and
		 self.expect('{') is not None and
		 (n1 := self.star_named_expressions()) is not None and
		 self.expect('}') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def setcomp(self):
		pos = self.mark()
		if (True and
		 self.expect('{') is not None and
		 (n1 := self.named_expression()) is not None and
		 (n2 := self.for_if_clauses()) is not None and
		 self.expect('}') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def dict(self):
		pos = self.mark()
		if (True and
		 self.expect('{') is not None and
		 ((n1 := self.synthetic_rule_123()) or True) is not None and
		 self.expect('}') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('{') is not None and
		 (n4 := self.invalid_double_starred_kvpairs()) is not None and
		 self.expect('}') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def dictcomp(self):
		pos = self.mark()
		if (True and
		 self.expect('{') is not None and
		 (n1 := self.kvpair()) is not None and
		 (n2 := self.for_if_clauses()) is not None and
		 self.expect('}') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def double_starred_kvpairs(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_125()) is not None and
		 ((n1 := self.synthetic_rule_126()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def double_starred_kvpair(self):
		pos = self.mark()
		if (True and
		 self.expect('**') is not None and
		 (n1 := self.bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.kvpair()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def kvpair(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expression()) is not None and
		 self.expect(':') is not None and
		 (n2 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def for_if_clauses(self):
		pos = self.mark()
		if (True and
		 NotImplemented(<class 'grammar.NameLeaf'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def for_if_clause(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.ASYNC)) is not None and
		 self.expect('for') is not None and
		 (n2 := self.star_targets()) is not None and
		 self.expect('in') is not None and
		 True is not None and
		 (n5 := self.disjunction()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('for') is not None and
		 (n8 := self.star_targets()) is not None and
		 self.expect('in') is not None and
		 True is not None and
		 (n11 := self.disjunction()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def yield_expr(self):
		pos = self.mark()
		if (True and
		 self.expect('yield') is not None and
		 self.expect('from') is not None and
		 (n2 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('yield') is not None and
		 ((n4 := self.synthetic_rule_129()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def arguments(self):
		pos = self.mark()
		if (True and
		 (n0 := self.args()) is not None and
		 ((n1 := self.synthetic_rule_130()) or True) is not None and
		 self.lookahead(&, self.expect, ')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def args(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_134()) is not None and
		 ((n1 := self.synthetic_rule_135()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.kwargs()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def kwargs(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_137()) is not None and
		 self.expect(',') is not None and
		 (n2 := self.synthetic_rule_139()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.synthetic_rule_141()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.synthetic_rule_143()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def starred_expression(self):
		pos = self.mark()
		if (True and
		 self.expect('*') is not None and
		 (n1 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def kwarg_or_starred(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NAME)) is not None and
		 self.expect('=') is not None and
		 (n2 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.starred_expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def kwarg_or_double_starred(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NAME)) is not None and
		 self.expect('=') is not None and
		 (n2 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('**') is not None and
		 (n4 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def star_targets(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_target()) is not None and
		 self.lookahead(!, self.expect, ',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.star_target()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		 ((n4 := self.synthetic_rule_145()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def star_targets_list_seq(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_147()) is not None and
		 ((n1 := self.synthetic_rule_148()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def star_targets_tuple_seq(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_target()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		 ((n2 := self.synthetic_rule_150()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.star_target()) is not None and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def star_target(self):
		pos = self.mark()
		if (True and
		 self.expect('*') is not None and
		 (n1 := self.synthetic_rule_151()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.target_with_star_atom()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def target_with_star_atom(self):
		pos = self.mark()
		if (True and
		 (n0 := self.t_primary()) is not None and
		 self.expect('.') is not None and
		 (n2 := self.expect(tokenize.NAME)) is not None and
		 self.lookahead(!, self.t_lookahead, ) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.t_primary()) is not None and
		 self.expect('[') is not None and
		 (n6 := self.slices()) is not None and
		 self.expect(']') is not None and
		 self.lookahead(!, self.t_lookahead, ) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n9 := self.star_atom()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def star_atom(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NAME)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		 (n2 := self.target_with_star_atom()) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		 ((n5 := self.synthetic_rule_152()) or True) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('[') is not None and
		 ((n8 := self.synthetic_rule_153()) or True) is not None and
		 self.expect(']') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def single_target(self):
		pos = self.mark()
		if (True and
		 (n0 := self.single_subscript_attribute_target()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.expect(tokenize.NAME)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		 (n3 := self.single_target()) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def single_subscript_attribute_target(self):
		pos = self.mark()
		if (True and
		 (n0 := self.t_primary()) is not None and
		 self.expect('.') is not None and
		 (n2 := self.expect(tokenize.NAME)) is not None and
		 self.lookahead(!, self.t_lookahead, ) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.t_primary()) is not None and
		 self.expect('[') is not None and
		 (n6 := self.slices()) is not None and
		 self.expect(']') is not None and
		 self.lookahead(!, self.t_lookahead, ) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def del_targets(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_155()) is not None and
		 ((n1 := self.synthetic_rule_156()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def del_target(self):
		pos = self.mark()
		if (True and
		 (n0 := self.t_primary()) is not None and
		 self.expect('.') is not None and
		 (n2 := self.expect(tokenize.NAME)) is not None and
		 self.lookahead(!, self.t_lookahead, ) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.t_primary()) is not None and
		 self.expect('[') is not None and
		 (n6 := self.slices()) is not None and
		 self.expect(']') is not None and
		 self.lookahead(!, self.t_lookahead, ) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n9 := self.del_t_atom()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def del_t_atom(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NAME)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		 (n2 := self.del_target()) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		 ((n5 := self.synthetic_rule_157()) or True) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('[') is not None and
		 ((n8 := self.synthetic_rule_158()) or True) is not None and
		 self.expect(']') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize_left_rec
	def t_primary(self):
		pos = self.mark()
		if (True and
		 (n0 := self.t_primary()) is not None and
		 self.expect('.') is not None and
		 (n2 := self.expect(tokenize.NAME)) is not None and
		 self.lookahead(&, self.t_lookahead, ) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n4 := self.t_primary()) is not None and
		 self.expect('[') is not None and
		 (n6 := self.slices()) is not None and
		 self.expect(']') is not None and
		 self.lookahead(&, self.t_lookahead, ) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n9 := self.t_primary()) is not None and
		 (n10 := self.genexp()) is not None and
		 self.lookahead(&, self.t_lookahead, ) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n12 := self.t_primary()) is not None and
		 self.expect('(') is not None and
		 ((n14 := self.synthetic_rule_159()) or True) is not None and
		 self.expect(')') is not None and
		 self.lookahead(&, self.t_lookahead, ) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n17 := self.atom()) is not None and
		 self.lookahead(&, self.t_lookahead, ) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def t_lookahead(self):
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('[') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('.') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def invalid_double_starred_kvpairs(self):
		pos = self.mark()
		if (True and
		 (n0 := self.synthetic_rule_161()) is not None and
		 self.expect(',') is not None and
		 (n2 := self.invalid_kvpair()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.expression()) is not None and
		 self.expect(':') is not None and
		 self.expect('*') is not None and
		 (n6 := self.bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n7 := self.expression()) is not None and
		 self.expect(':') is not None and
		 self.lookahead(&, self.expect, ('}' | ',')) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def invalid_kvpair(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expression()) is not None and
		 self.lookahead(!, self.expect, (':')) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.expression()) is not None and
		 self.expect(':') is not None and
		 self.expect('*') is not None and
		 (n5 := self.bitwise_or()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n6 := self.expression()) is not None and
		 self.expect(':') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_0(self):
		pos = self.mark()
		if (True and
		 (n0 := self.statements()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_1(self):
		pos = self.mark()
		if (True and
		 (n0 := self.type_expressions()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_2(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_3(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expression()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_4(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_5(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expression()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_6(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_7(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expression()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_8(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_9(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expression()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_10(self):
		pos = self.mark()
		if (True and
		 self.expect(';') is not None and
		 (n1 := self.simple_stmt()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_11(self):
		pos = self.mark()
		if (True and
		 (n0 := self.simple_stmt()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_12(self):
		pos = self.mark()
		if (True and
		 self.expect(';') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_13(self):
		pos = self.mark()
		if (True and
		 self.expect('=') is not None and
		 (n1 := self.annotated_rhs()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_14(self):
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		 (n1 := self.single_target()) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.single_subscript_attribute_target()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_15(self):
		pos = self.mark()
		if (True and
		 self.expect('=') is not None and
		 (n1 := self.annotated_rhs()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_16(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_targets()) is not None and
		 self.expect('=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_17(self):
		pos = self.mark()
		if (True and
		 (n0 := self.yield_expr()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.star_expressions()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_18(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.TYPE_COMMENT)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_19(self):
		pos = self.mark()
		if (True and
		 (n0 := self.yield_expr()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.star_expressions()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_20(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.expect(tokenize.NAME)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_21(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NAME)) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_22(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.expect(tokenize.NAME)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_23(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NAME)) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_24(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_25(self):
		pos = self.mark()
		if (True and
		 self.expect(';') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.expect(tokenize.NEWLINE)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_26(self):
		pos = self.mark()
		if (True and
		 self.expect('.') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('...') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_27(self):
		pos = self.mark()
		if (True and
		 self.expect('.') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('...') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_28(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_29(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.import_from_as_name()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_30(self):
		pos = self.mark()
		if (True and
		 (n0 := self.import_from_as_name()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_31(self):
		pos = self.mark()
		if (True and
		 self.expect('as') is not None and
		 (n1 := self.expect(tokenize.NAME)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_32(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.dotted_as_name()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_33(self):
		pos = self.mark()
		if (True and
		 (n0 := self.dotted_as_name()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_34(self):
		pos = self.mark()
		if (True and
		 self.expect('as') is not None and
		 (n1 := self.expect(tokenize.NAME)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_35(self):
		pos = self.mark()
		if (True and
		 (n0 := self.else_block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_36(self):
		pos = self.mark()
		if (True and
		 (n0 := self.else_block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_37(self):
		pos = self.mark()
		if (True and
		 (n0 := self.else_block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_38(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.TYPE_COMMENT)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_39(self):
		pos = self.mark()
		if (True and
		 (n0 := self.else_block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_40(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.TYPE_COMMENT)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_41(self):
		pos = self.mark()
		if (True and
		 (n0 := self.else_block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_42(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.with_item()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_43(self):
		pos = self.mark()
		if (True and
		 (n0 := self.with_item()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_44(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.with_item()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_45(self):
		pos = self.mark()
		if (True and
		 (n0 := self.with_item()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_46(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.TYPE_COMMENT)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_47(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.with_item()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_48(self):
		pos = self.mark()
		if (True and
		 (n0 := self.with_item()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_49(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.with_item()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_50(self):
		pos = self.mark()
		if (True and
		 (n0 := self.with_item()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_51(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.TYPE_COMMENT)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_52(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect(':') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_53(self):
		pos = self.mark()
		if (True and
		 (n0 := self.else_block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_54(self):
		pos = self.mark()
		if (True and
		 (n0 := self.finally_block()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_55(self):
		pos = self.mark()
		if (True and
		 self.expect('as') is not None and
		 (n1 := self.expect(tokenize.NAME)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_56(self):
		pos = self.mark()
		if (True and
		 self.expect('|') is not None and
		 (n1 := self.closed_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_57(self):
		pos = self.mark()
		if (True and
		 (n0 := self.closed_pattern()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_58(self):
		pos = self.mark()
		if (True and
		 self.expect('+') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('-') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_59(self):
		pos = self.mark()
		if (True and
		 self.expect('+') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('-') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_60(self):
		pos = self.mark()
		if (True and
		 self.expect('.') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_61(self):
		pos = self.mark()
		if (True and
		 self.expect('.') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect('=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_62(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.maybe_star_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_63(self):
		pos = self.mark()
		if (True and
		 (n0 := self.maybe_star_pattern()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_64(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.key_value_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_65(self):
		pos = self.mark()
		if (True and
		 (n0 := self.key_value_pattern()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_66(self):
		pos = self.mark()
		if (True and
		 (n0 := self.literal_expr()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.attr()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_67(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_68(self):
		pos = self.mark()
		if (True and
		 (n0 := self.pattern()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_69(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.keyword_pattern()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_70(self):
		pos = self.mark()
		if (True and
		 (n0 := self.keyword_pattern()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_71(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_expressions()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_72(self):
		pos = self.mark()
		if (True and
		 self.expect('from') is not None and
		 (n1 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_73(self):
		pos = self.mark()
		if (True and
		 (n0 := self.params()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_74(self):
		pos = self.mark()
		if (True and
		 self.expect('->') is not None and
		 (n1 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_75(self):
		pos = self.mark()
		if (True and
		 (n0 := self.func_type_comment()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_76(self):
		pos = self.mark()
		if (True and
		 (n0 := self.params()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_77(self):
		pos = self.mark()
		if (True and
		 self.expect('->') is not None and
		 (n1 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_78(self):
		pos = self.mark()
		if (True and
		 (n0 := self.func_type_comment()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_79(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expect(tokenize.NEWLINE)) is not None and
		 (n1 := self.expect(tokenize.INDENT)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_80(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_etc()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_81(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_etc()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_82(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_etc()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_83(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_etc()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_84(self):
		pos = self.mark()
		if (True and
		 (n0 := self.kwds()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_85(self):
		pos = self.mark()
		if (True and
		 (n0 := self.kwds()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_86(self):
		pos = self.mark()
		if (True and
		 self.expect('@') is not None and
		 (n1 := self.named_expression()) is not None and
		 (n2 := self.expect(tokenize.NEWLINE)) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_87(self):
		pos = self.mark()
		if (True and
		 (n0 := self.arguments()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_88(self):
		pos = self.mark()
		if (True and
		 self.expect('(') is not None and
		 ((n1 := self.synthetic_rule_88()) or True) is not None and
		 self.expect(')') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_89(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.star_expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_90(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_91(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.star_named_expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_92(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_named_expression()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_93(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_94(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_95(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_96(self):
		pos = self.mark()
		if (True and
		 (n0 := self.lambda_params()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_97(self):
		pos = self.mark()
		if (True and
		 (n0 := self.lambda_star_etc()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_98(self):
		pos = self.mark()
		if (True and
		 (n0 := self.lambda_star_etc()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_99(self):
		pos = self.mark()
		if (True and
		 (n0 := self.lambda_star_etc()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_100(self):
		pos = self.mark()
		if (True and
		 (n0 := self.lambda_star_etc()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_101(self):
		pos = self.mark()
		if (True and
		 (n0 := self.lambda_kwds()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_102(self):
		pos = self.mark()
		if (True and
		 (n0 := self.lambda_kwds()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_103(self):
		pos = self.mark()
		if (True and
		 self.expect('or') is not None and
		 (n1 := self.conjunction()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_104(self):
		pos = self.mark()
		if (True and
		 self.expect('and') is not None and
		 (n1 := self.inversion()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_105(self):
		pos = self.mark()
		if (True and
		 self.expect('!=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_106(self):
		pos = self.mark()
		if (True and
		 (n0 := self.arguments()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_107(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.slice()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_108(self):
		pos = self.mark()
		if (True and
		 (n0 := self.slice()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_109(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_110(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_111(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_112(self):
		pos = self.mark()
		if (True and
		 (n0 := self.expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_113(self):
		pos = self.mark()
		if (True and
		 self.expect(':') is not None and
		 ((n1 := self.synthetic_rule_113()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_114(self):
		pos = self.mark()
		if (True and
		 (n0 := self.tuple()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.group()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.genexp()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_115(self):
		pos = self.mark()
		if (True and
		 (n0 := self.list()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.listcomp()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_116(self):
		pos = self.mark()
		if (True and
		 (n0 := self.dict()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.set()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.dictcomp()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n3 := self.setcomp()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_117(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_named_expressions()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_118(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_named_expressions()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_119(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_named_expression()) is not None and
		 self.expect(',') is not None and
		 ((n2 := self.synthetic_rule_119()) or True) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_120(self):
		pos = self.mark()
		if (True and
		 (n0 := self.yield_expr()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.named_expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_121(self):
		pos = self.mark()
		if (True and
		 (n0 := self.assignment_expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.expression()) is not None and
		 self.lookahead(!, self.expect, ':=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_122(self):
		pos = self.mark()
		if (True and
		 (n0 := self.double_starred_kvpairs()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_123(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.double_starred_kvpair()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_124(self):
		pos = self.mark()
		if (True and
		 (n0 := self.double_starred_kvpair()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_125(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_126(self):
		pos = self.mark()
		if (True and
		 self.expect('if') is not None and
		 (n1 := self.disjunction()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_127(self):
		pos = self.mark()
		if (True and
		 self.expect('if') is not None and
		 (n1 := self.disjunction()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_128(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_expressions()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_129(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_130(self):
		pos = self.mark()
		if (True and
		 (n0 := self.assignment_expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.expression()) is not None and
		 self.lookahead(!, self.expect, ':=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_131(self):
		pos = self.mark()
		if (True and
		 (n0 := self.assignment_expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.expression()) is not None and
		 self.lookahead(!, self.expect, ':=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_132(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.starred_expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n2 := self.synthetic_rule_132()) is not None and
		 self.lookahead(!, self.expect, '=') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_133(self):
		pos = self.mark()
		if (True and
		 (n0 := self.starred_expression()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 (n1 := self.synthetic_rule_131()) is not None and
		 self.lookahead(!, self.expect, '=') is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_134(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.kwargs()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_135(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.kwarg_or_starred()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_136(self):
		pos = self.mark()
		if (True and
		 (n0 := self.kwarg_or_starred()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_137(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.kwarg_or_double_starred()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_138(self):
		pos = self.mark()
		if (True and
		 (n0 := self.kwarg_or_double_starred()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_139(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.kwarg_or_starred()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_140(self):
		pos = self.mark()
		if (True and
		 (n0 := self.kwarg_or_starred()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_141(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.kwarg_or_double_starred()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_142(self):
		pos = self.mark()
		if (True and
		 (n0 := self.kwarg_or_double_starred()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_143(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.star_target()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_144(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_145(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.star_target()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_146(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_target()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_147(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_148(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.star_target()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_149(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_150(self):
		pos = self.mark()
		if (True and
		 self.lookahead(!, self.expect, '*') is not None and
		 (n1 := self.star_target()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_151(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_targets_tuple_seq()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_152(self):
		pos = self.mark()
		if (True and
		 (n0 := self.star_targets_list_seq()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_153(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.del_target()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_154(self):
		pos = self.mark()
		if (True and
		 (n0 := self.del_target()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_155(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_156(self):
		pos = self.mark()
		if (True and
		 (n0 := self.del_targets()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_157(self):
		pos = self.mark()
		if (True and
		 (n0 := self.del_targets()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_158(self):
		pos = self.mark()
		if (True and
		 (n0 := self.arguments()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_159(self):
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		 (n1 := self.double_starred_kvpair()) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_160(self):
		pos = self.mark()
		if (True and
		 (n0 := self.double_starred_kvpair()) is not None and
		 NotImplemented(<class 'grammar.Group'>) is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_161(self):
		pos = self.mark()
		if (True and
		 self.expect('}') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		pos = self.mark()
		if (True and
		 self.expect(',') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

	@memoize
	def synthetic_rule_162(self):
		pos = self.mark()
		if (True and
		 self.expect(':') is not None and
		   True):
			return "Not True"
		self.reset(pos)
		return None

