file: [statements] ENDMARKER { _a } 
interactive: statement_newline { _a }
eval: expressions NEWLINE* ENDMARKER { _a }
func_type: '(' [type_expressions] ')' '->' expression NEWLINE* ENDMARKER { _a } 
fstring: star_expressions { _a }

# type_expressions allow */** but ignore them
type_expressions:
    | (expression (',' expression)*) ',' '*' expression ',' '**' expression { _a }
    | (expression (',' expression)*) ',' '*' expression { _a }
    | (expression (',' expression)*) ',' '**' expression { _a } 
    | '*' expression ',' '**' expression { _a } 
    | '*' expression { _a }
    | '**' expression { _a }
    | (expression (',' expression)*) { _a } 

statements: statement+ { _a }
statement: compound_stmt { _a }  | simple_stmts { _a } 
statement_newline: 
    | compound_stmt NEWLINE { _a } 
    | simple_stmts { _a } 
    | NEWLINE { _a } 
    | ENDMARKER { _a }
simple_stmts:
    | simple_stmt !';' NEWLINE { _a }   # Not needed, there for speedup
    | (simple_stmt (';' simple_stmt)*) [';'] NEWLINE { _a }
# NOTE: assignment MUST precede expression, else parsing a simple assignment
# will throw a SyntaxError.
simple_stmt:
    | assignment { _a } 
    | star_expressions { _a } 
    | return_stmt { _a } 
    | import_stmt { _a } 
    | raise_stmt { _a } 
    | 'pass' { _a } 
    | del_stmt { _a } 
    | yield_stmt { _a } 
    | assert_stmt { _a } 
    | 'break' { _a } 
    | 'continue' { _a } 
    | global_stmt { _a } 
    | nonlocal_stmt { _a }
compound_stmt:
    | function_def { _a } 
    | if_stmt { _a } 
    | class_def { _a } 
    | with_stmt { _a } 
    | for_stmt { _a } 
    | try_stmt { _a } 
    | while_stmt { _a } 
    | match_stmt { _b }

# NOTE: annotated_rhs may start with 'yield'; yield_expr must start with 'yield'
assignment:
    | NAME ':' expression ['=' annotated_rhs ] { _a } 
    | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs ] { _a } 
    | (star_targets '=' )+ (yield_expr | star_expressions) !'=' [TYPE_COMMENT] { _a } 
    | single_target augassign ~ (yield_expr | star_expressions) { _a }
augassign:
    | '+=' { _a } 
    | '-=' { _a } 
    | '*=' { _a } 
    | '@=' { _a } 
    | '/=' { _a } 
    | '%=' { _a } 
    | '&=' { _a } 
    | '|=' { _a } 
    | '^=' { _a } 
    | '<<=' { _a } 
    | '>>=' { _a } 
    | '**=' { _a } 
    | '//=' {_a}

global_stmt: 'global' (NAME (',' NAME)*) { _a }
nonlocal_stmt: 'nonlocal' (NAME (',' NAME)*) { _a }

yield_stmt: yield_expr { _a }

assert_stmt: 'assert' expression [',' expression ] { _a } 

del_stmt:
    | 'del' del_targets &(';' | NEWLINE) { _a }
import_stmt: import_name { _a } | import_from { _a }
import_name: 'import' dotted_as_names { _a }
# note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSIS
import_from:
    | 'from' ('.' | '...')* dotted_name 'import' import_from_targets { _a }  
    | 'from' ('.' | '...')+ 'import' import_from_targets { _a }
import_from_targets:
    | '(' import_from_as_names [','] ')' { _a } 
    | import_from_as_names !',' { _a } 
    | '*' { _a }
import_from_as_names:
    | (import_from_as_name (',' import_from_as_name)*) { _a }
import_from_as_name:
    | NAME ['as' NAME ] { _a }
dotted_as_names:
    | (dotted_as_name (',' dotted_as_name)*) { _a }
dotted_as_name:
    | dotted_name ['as' NAME ] { _a }
dotted_name:
    | dotted_name '.' NAME { _a } 
    | NAME { _a }

if_stmt:
    | 'if' named_expression ':' block elif_stmt { _a } 
    | 'if' named_expression ':' block [else_block] { _a } 
elif_stmt:
    | 'elif' named_expression ':' block elif_stmt { _a } 
    | 'elif' named_expression ':' block [else_block] { _a }
else_block:
    | 'else' ':' block { _a }

while_stmt:
    | 'while' named_expression ':' block [else_block] { _a } 

for_stmt:
    | 'for' star_targets 'in' ~ star_expressions ':' [TYPE_COMMENT] block [else_block] { _a } 
    | ASYNC 'for' star_targets 'in' ~ star_expressions ':' [TYPE_COMMENT] block [else_block] { _a } 
with_stmt:
    | 'with' '(' (with_item (',' with_item)*) ','? ')' ':' block { _a } 
    | 'with' (with_item (',' with_item)*) ':' [TYPE_COMMENT] block { _a } 
    | ASYNC 'with' '(' (with_item (',' with_item)*) ','? ')' ':' block { _a } 
    | ASYNC 'with' (with_item (',' with_item)*) ':' [TYPE_COMMENT] block { _a }
with_item:
    | expression 'as' star_target &(',' | ')' | ':') { _a } 
    | expression { _a }

try_stmt:
    | 'try' ':' block finally_block { _a } 
    | 'try' ':' block except_block+ [else_block] [finally_block] { _a } 
except_block:
    | 'except' expression ['as' NAME ] ':' block { _a } 
    | 'except' ':' block { _a }
finally_block:
    | 'finally' ':' block { _a }

match_stmt:
    | "match" subject_expr ':' NEWLINE INDENT case_block+ DEDENT { _a } 
subject_expr:
    | star_named_expression ',' star_named_expressions? { _a } 
    | named_expression { _a }
case_block:
    | "case" patterns guard? ':' block { _a } 
guard: 'if' named_expression { _a }

patterns:
    | open_sequence_pattern { _a } 
    | pattern { _a }
pattern:
    | as_pattern { _a } 
    | or_pattern { _a }
as_pattern:
    | or_pattern 'as' pattern_capture_target { _a }
or_pattern:
    | (closed_pattern ('|' closed_pattern)*) { _a }
closed_pattern:
    | literal_pattern { _a } 
    | capture_pattern { _a } 
    | wildcard_pattern { _a } 
    | value_pattern { _a } 
    | group_pattern { _a } 
    | sequence_pattern { _a } 
    | mapping_pattern { _a } 
    | class_pattern { _a }

# Literal patterns are used for equality and identity constraints
literal_pattern:
    | signed_number !('+' | '-') { _a } 
    | complex_number { _a } 
    | strings { _a } 
    | 'None' { _a } 
    | 'True' { _a } 
    | 'False' { _a }

# Literal expressions are used to restrict permitted mapping pattern keys
literal_expr:
    | signed_number !('+' | '-') { _a } 
    | complex_number { _a } 
    | strings { _a } 
    | 'None' { _a } 
    | 'True' { _a } 
    | 'False' { _a }

complex_number:
    | signed_real_number '+' imaginary_number { _a } 
    | signed_real_number '-' imaginary_number { _a }  

signed_number:
    | NUMBER { _a } 
    | '-' NUMBER { _a }

signed_real_number:
    | real_number { _a } 
    | '-' real_number { _a }

real_number:
    | NUMBER { _a }

imaginary_number:
    | NUMBER { _a }

capture_pattern:
    | pattern_capture_target { _a }

pattern_capture_target:
    | !"_" NAME !('.' | '(' | '=') { _a }

wildcard_pattern:
    | "_" { _a }

value_pattern:
    | attr !('.' | '(' | '=') { _a }
attr:
    | name_or_attr '.' NAME { _a }
name_or_attr:
    | attr { _a } 
    | NAME { _a }

group_pattern:
    | '(' pattern ')' { _a }

sequence_pattern:
    | '[' maybe_sequence_pattern? ']' { _a } 
    | '(' open_sequence_pattern? ')' { _a }
open_sequence_pattern:
    | maybe_star_pattern ',' maybe_sequence_pattern? { _a }
maybe_sequence_pattern:
    | (maybe_star_pattern (',' maybe_star_pattern)*) ','? { _a }
maybe_star_pattern:
    | star_pattern { _a } 
    | pattern { _a }
star_pattern:
    | '*' pattern_capture_target { _a }  
    | '*' wildcard_pattern { _a }

mapping_pattern:
    | '{' '}' { _a } 
    | '{' double_star_pattern ','? '}' { _a } 
    | '{' items_pattern ',' double_star_pattern ','? '}' { _a } 
    | '{' items_pattern ','? '}' { _a }
items_pattern:
    | (key_value_pattern (',' key_value_pattern)*) { _a }
key_value_pattern:
    | (literal_expr | attr) ':' pattern { _a }
double_star_pattern:
    | '**' pattern_capture_target { _a }

class_pattern:
    | name_or_attr '(' ')' { _a } 
    | name_or_attr '(' positional_patterns ','? ')' { _a } 
    | name_or_attr '(' keyword_patterns ','? ')' { _a } 
    | name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')' { _a }
positional_patterns:
    | (pattern (',' pattern)*) { _a }
keyword_patterns:
    | (keyword_pattern (',' keyword_pattern)*) { _a }
keyword_pattern:
    | NAME '=' pattern { _a }

return_stmt:
    | 'return' [star_expressions] { _a }

raise_stmt:
    | 'raise' expression ['from' expression ] { _a } 
    | 'raise' { _a }

function_def:
    | decorators function_def_raw { _a } 
    | function_def_raw { _a }

function_def_raw:
    | 'def' NAME '(' [params] ')' ['->' expression ] ':' [func_type_comment] block { _a } 
    | ASYNC 'def' NAME '(' [params] ')' ['->' expression ] ':' [func_type_comment] block { _a }
func_type_comment:
    | NEWLINE TYPE_COMMENT &(NEWLINE INDENT) { _a } # Must be followed by indented block
    | TYPE_COMMENT { _a }

params:
    | parameters { _a }

parameters:
    | slash_no_default param_no_default* param_with_default* [star_etc] { _a } 
    | slash_with_default param_with_default* [star_etc] { _a } 
    | param_no_default+ param_with_default* [star_etc] { _a } 
    | param_with_default+ [star_etc] { _a } 
    | star_etc  { _a }

# Some duplication here because we can't write (',' | &')'),
# which is because we don't support empty alternatives (yet).
#
slash_no_default:
    | param_no_default+ '/' ',' { _a } 
    | param_no_default+ '/' &')' { _a }
slash_with_default:
    | param_no_default* param_with_default+ '/' ',' { _a } 
    | param_no_default* param_with_default+ '/' &')' { _a }

star_etc:
    | '*' param_no_default param_maybe_default* [kwds] { _a } 
    | '*' ',' param_maybe_default+ [kwds] { _a } 
    | kwds { _a }
kwds: '**' param_no_default { _a }

# One parameter.  This *includes* a following comma and type comment.
#
# There are three styles:
# - No default
# - With default
# - Maybe with default
#
# There are two alternative forms of each, to deal with type comments:
# - Ends in a comma followed by an optional type comment
# - No comma, optional type comment, must be followed by close paren
# The latter form is for a final parameter without trailing comma.
#
param_no_default:
    | param ',' TYPE_COMMENT? { _a } 
    | param TYPE_COMMENT? &')' { _a }
param_with_default:
    | param default ',' TYPE_COMMENT? { _a } 
    | param default TYPE_COMMENT? &')' { _a }
param_maybe_default:
    | param default? ',' TYPE_COMMENT? { _a } 
    | param default? TYPE_COMMENT? &')' { _a }
param: NAME annotation? { _a }

annotation: ':' expression { _a }
default: '=' expression { _a }

decorators: ('@' named_expression NEWLINE )+ { _a }

class_def:
    | decorators class_def_raw { _a } 
    | class_def_raw { _a }
class_def_raw:
    | 'class' NAME ['(' [arguments] ')' ] ':' block { _a }

block:
    | NEWLINE INDENT statements DEDENT { _a } 
    | simple_stmts { _a }
star_expressions:
    | star_expression (',' star_expression )+ [','] { _a } 
    | star_expression ',' { _a } 
    | star_expression { _a }
star_expression:
    | '*' bitwise_or { _a } 
    | expression { _a }

star_named_expressions: (star_named_expression (',' star_named_expression)*) [','] { _a }
star_named_expression:
    | '*' bitwise_or { _a } 
    | named_expression { _a }


assignment_expression:
    | NAME ':=' ~ expression { _a }

named_expression:
    | assignment_expression { _a } 
    | expression !':=' { _a }

annotated_rhs: yield_expr { _a }  | star_expressions { _a }

expressions:
    | expression (',' expression )+ [','] { _a } 
    | expression ',' { _a } 
    | expression { _a }
expression:
    | disjunction 'if' disjunction 'else' expression { _a } 
    | disjunction { _a } 
    | lambdef { _a }

lambdef:
    | 'lambda' [lambda_params] ':' expression { _a }

lambda_params:
    | lambda_parameters { _a }

# lambda_parameters etc. duplicates parameters but without annotations
# or type comments, and if there's no comma after a parameter, we expect
# a colon, not a close parenthesis.  (For more, see parameters above.)
#
lambda_parameters:
    | lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* [lambda_star_etc] { _a } 
    | lambda_slash_with_default lambda_param_with_default* [lambda_star_etc] { _a } 
    | lambda_param_no_default+ lambda_param_with_default* [lambda_star_etc] { _a } 
    | lambda_param_with_default+ [lambda_star_etc] { _a } 
    | lambda_star_etc { _a }

lambda_slash_no_default:
    | lambda_param_no_default+ '/' ',' { _a } 
    | lambda_param_no_default+ '/' &':' { _a }
lambda_slash_with_default:
    | lambda_param_no_default* lambda_param_with_default+ '/' ',' { _a } 
    | lambda_param_no_default* lambda_param_with_default+ '/' &':' { _a }

lambda_star_etc:
    | '*' lambda_param_no_default lambda_param_maybe_default* [lambda_kwds] { _a } 
    | '*' ',' lambda_param_maybe_default+ [lambda_kwds] { _a } 
    | lambda_kwds { _a }
lambda_kwds: '**' lambda_param_no_default { _a }

lambda_param_no_default:
    | lambda_param ',' { _a } 
    | lambda_param &':' { _a }
lambda_param_with_default:
    | lambda_param default ',' { _a } 
    | lambda_param default &':' { _a }
lambda_param_maybe_default:
    | lambda_param default? ',' { _a } 
    | lambda_param default? &':' { _a }
lambda_param: NAME { _a }

disjunction:
    | conjunction ('or' conjunction )+ { _a } 
    | conjunction { _a }
conjunction:
    | inversion ('and' inversion )+ { _a } 
    | inversion { _a }
inversion:
    | 'not' inversion { _a } 
    | comparison { _a }
comparison:
    | bitwise_or compare_op_bitwise_or_pair+ { _a } 
    | bitwise_or { _a }
compare_op_bitwise_or_pair:
    | eq_bitwise_or { _a } 
    | noteq_bitwise_or { _a } 
    | lte_bitwise_or { _a } 
    | lt_bitwise_or { _a } 
    | gte_bitwise_or { _a } 
    | gt_bitwise_or { _a } 
    | notin_bitwise_or { _a } 
    | in_bitwise_or { _a } 
    | isnot_bitwise_or { _a } 
    | is_bitwise_or { _a }
eq_bitwise_or: '==' bitwise_or { _a }
noteq_bitwise_or:
    | ('!=' ) bitwise_or { _a }
lte_bitwise_or: '<=' bitwise_or { _a }
lt_bitwise_or: '<' bitwise_or { _a }
gte_bitwise_or: '>=' bitwise_or { _a }
gt_bitwise_or: '>' bitwise_or { _a }
notin_bitwise_or: 'not' 'in' bitwise_or { _a }
in_bitwise_or: 'in' bitwise_or { _a }
isnot_bitwise_or: 'is' 'not' bitwise_or { _a }
is_bitwise_or: 'is' bitwise_or { _a }

bitwise_or:
    | bitwise_or '|' bitwise_xor { _a } 
    | bitwise_xor { _a }
bitwise_xor:
    | bitwise_xor '^' bitwise_and { _a } 
    | bitwise_and { _a }
bitwise_and:
    | bitwise_and '&' shift_expr { _a } 
    | shift_expr { _a }
shift_expr:
    | shift_expr '<<' sum { _a } 
    | shift_expr '>>' sum { _a } 
    | sum { _a }

sum:
    | sum '+' term { _a } 
    | sum '-' term { _a } 
    | term { _a }
term:
    | term '*' factor { _a } 
    | term '/' factor { _a } 
    | term '//' factor { _a } 
    | term '%' factor { _a } 
    | term '@' factor { _a } 
    | factor { _a }
factor:
    | '+' factor { _a } 
    | '-' factor { _a } 
    | '~' factor { _a } 
    | power { _a }
power:
    | await_primary '**' factor { _a } 
    | await_primary { _a }
await_primary:
    | AWAIT primary { _a } 
    | primary { _a }
primary:
    | primary '.' NAME { _a } 
    | primary genexp { _a } 
    | primary '(' [arguments] ')' { _a } 
    | primary '[' slices ']' { _a } 
    | atom { _a }

slices:
    | slice !',' { _a } 
    | (slice (',' slice)*) [','] { _a }
slice:
    | [expression] ':' [expression] [':' [expression] ] { _a } 
    | named_expression { _a }
atom:
    | NAME { _a } 
    | 'True' { _a } 
    | 'False' { _a } 
    | 'None' { _a } 
    | strings { _a } 
    | NUMBER { _a } 
    | (tuple | group | genexp) { _a } 
    | (list | listcomp) { _a } 
    | (dict | set | dictcomp | setcomp) { _a } 
    | '...' { _a }

strings: STRING+ { _a }
list:
    | '[' [star_named_expressions] ']' { _a }
listcomp:
    | '[' named_expression for_if_clauses ']' { _a }
tuple:
    | '(' [star_named_expression ',' [star_named_expressions]  ] ')' { _a }
group:
    | '(' (yield_expr | named_expression) ')' { _a }
genexp:
    | '(' ( assignment_expression | expression !':=') for_if_clauses ')' { _a }
set: '{' star_named_expressions '}' { _a }
setcomp:
    | '{' named_expression for_if_clauses '}' { _a }
dict:
    | '{' [double_starred_kvpairs] '}' { _a } 
    | '{' invalid_double_starred_kvpairs '}'{ _a }

dictcomp:
    | '{' kvpair for_if_clauses '}' { _a }
double_starred_kvpairs: (double_starred_kvpair (',' double_starred_kvpair)*) [','] { _a }
double_starred_kvpair:
    | '**' bitwise_or { _a } 
    | kvpair { _a }
kvpair: expression ':' expression { _a }
for_if_clauses:
    | for_if_clause+ { _a }
for_if_clause:
    | ASYNC 'for' star_targets 'in' ~ disjunction ('if' disjunction )* { _a } 
    | 'for' star_targets 'in' ~ disjunction ('if' disjunction )* { _a }
yield_expr:
    | 'yield' 'from' expression { _a } 
    | 'yield' [star_expressions] { _a }

arguments:
    | args [','] &')' { _a }
args:
    | (starred_expression | ( assignment_expression | expression !':=') !'=' (',' starred_expression | ( assignment_expression | expression !':=') !'=')*) [',' kwargs ] { _a } 
    | kwargs { _a }

kwargs:
    | (kwarg_or_starred (',' kwarg_or_starred)*) ',' (kwarg_or_double_starred (',' kwarg_or_double_starred)*) { _a } 
    | (kwarg_or_starred (',' kwarg_or_starred)*) { _a } 
    | (kwarg_or_double_starred (',' kwarg_or_double_starred)*) { _a }
starred_expression:
    | '*' expression { _a }
kwarg_or_starred:
    | NAME '=' expression { _a } 
    | starred_expression { _a }
kwarg_or_double_starred:
    | NAME '=' expression { _a } 
    | '**' expression { _a }

# NOTE: star_targets may contain *bitwise_or, targets may not.
star_targets:
    | star_target !',' { _a } 
    | star_target (',' star_target )* [','] { _a }
star_targets_list_seq: (star_target (',' star_target)*) [','] { _a }
star_targets_tuple_seq:
    | star_target (',' star_target )+ [','] { _a } 
    | star_target ',' { _a }
star_target:
    | '*' (!'*' star_target) { _a } 
    | target_with_star_atom { _a }
target_with_star_atom:
    | t_primary '.' NAME !t_lookahead { _a } 
    | t_primary '[' slices ']' !t_lookahead { _a } 
    | star_atom { _a }
star_atom:
    | NAME { _a } 
    | '(' target_with_star_atom ')' { _a } 
    | '(' [star_targets_tuple_seq] ')' { _a } 
    | '[' [star_targets_list_seq] ']' { _a }

single_target:
    | single_subscript_attribute_target { _a } 
    | NAME { _a } 
    | '(' single_target ')' { _a }
single_subscript_attribute_target:
    | t_primary '.' NAME !t_lookahead { _a } 
    | t_primary '[' slices ']' !t_lookahead { _a }

del_targets: (del_target (',' del_target)*) [','] { _a }
del_target:
    | t_primary '.' NAME !t_lookahead { _a } 
    | t_primary '[' slices ']' !t_lookahead { _a } 
    | del_t_atom { _a }
del_t_atom:
    | NAME { _a } 
    | '(' del_target ')' { _a } 
    | '(' [del_targets] ')' { _a } 
    | '[' [del_targets] ']' { _a }

t_primary:
    | t_primary '.' NAME &t_lookahead { _a } 
    | t_primary '[' slices ']' &t_lookahead { _a } 
    | t_primary genexp &t_lookahead { _a } 
    | t_primary '(' [arguments] ')' &t_lookahead { _a } 
    | atom &t_lookahead { _a }
t_lookahead: '(' { _a }  | '[' { _a }  | '.' { _a }

invalid_double_starred_kvpairs:
    | (double_starred_kvpair (',' double_starred_kvpair)*) ',' invalid_kvpair { _a } 
    | expression ':' '*' bitwise_or { _a } 
    | expression ':' &('}'|',') { _a }

invalid_kvpair:
    | expression !(':') { _a } 
    | expression ':' '*' bitwise_or { _a } 
    | expression ':' { _a }